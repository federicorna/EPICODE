<!--
TETRATRIS

In tetratris, lo scopo è fare quattro segni di fila, X o O, in fila orizzontale, verticale o orizzontale. La griglia principale è di quattro per quattro, ma puoi estenderla verso l’esterno muovendo i tuoi pezzi.

All’inizio si gioca piazzando i segni dentro la griglia. Quando un tuo segno si trova sul bordo, puoi scegliere di muoverlo. Spostandolo, la casella da cui lo prendi diventa un buco non riuttilizzabile e il segno va messo fuori dalla griglia, attaccato ad una casella sempre sul bordo indipendentemente dal segno associato in orizzontale o verticale, ma non in diagonale. I pezzi spostati fuori possono continuare a fare da base per altri pezzi.

Qui sotto, il codice html creato con chatGPT per dare un idea.
-->



<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Quatris con Vincitore</title>
<style>
:root{--cell:60px;--gap:5px;}
body{font-family:sans-serif;background:#0b0f1a;color:#e6eef8;padding:20px;}
h1{margin-bottom:15px;}
.grid{display:grid;gap:var(--gap);background:#081226;padding:10px;border-radius:8px;position:relative;}
.cell{width:var(--cell);height:var(--cell);display:flex;align-items:center;justify-content:center;
cursor:pointer;border-radius:6px;font-weight:bold;font-size:20px;}
.cell.empty{background:#031017;}
.cell.buffer{background:rgba(30,30,50,0.2);}
.cell.X{background:#334155;color:#fef3c7;}
.cell.O{background:#1e293b;color:#cbe7ff;}
.cell.hole{background:#001014;border:2px dashed #334155;}
.selected{outline:3px solid #2563eb;}
.cell.valid{outline:3px solid #16a34a;}
.controls{margin-top:15px;}
.btn{padding:8px 12px;margin-right:6px;border:none;border-radius:6px;background:#2563eb;color:#fff;cursor:pointer;}
.info{margin-top:10px;}
#winnerPopup{
  position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);
  background:#1e293b;padding:20px;border-radius:10px;text-align:center;
  display:none; z-index:10; color:#fef3c7; font-size:24px; border:2px solid #16a34a;
}
#winnerPopup button{margin-top:15px;padding:8px 12px;background:#2563eb;border:none;border-radius:6px;color:#fff;cursor:pointer;}
</style>
</head>
<body>
<h1>Quatris con Vincitore</h1>
<div id="grid" class="grid"></div>
<div class="controls">
<button class="btn" id="placeBtn">Piazza</button>
<button class="btn" id="moveBtn">Muovi</button>
<button class="btn" id="resetBtn">Reset</button>
</div>
<div class="info" id="status">Modalità Piazza: piazza X.</div>

<div id="winnerPopup">
  <div id="winnerText"></div>
  <button onclick="document.getElementById('winnerPopup').style.display='none';">Chiudi</button>
</div>

<script>
const ROWS=4, COLS=4;
const BUFFER=3; 
let board=[];
let current='X';
let mode='place';
let selected=null;
let validTargets = new Set();
let gameOver=false;

for(let r=0;r<ROWS;r++){
  board[r]=[];
  for(let c=0;c<COLS;c++){
    board[r][c]={v:null,hole:false};
  }
}

let external = new Map();

const grid=document.getElementById('grid');
const status=document.getElementById('status');
const winnerPopup=document.getElementById('winnerPopup');
const winnerText=document.getElementById('winnerText');

function render(){
  grid.innerHTML='';
  if(gameOver){status.textContent='Gioco finito: '+current+' ha vinto!'; return;}

  let rMin=-BUFFER, rMax=ROWS-1+BUFFER, cMin=-BUFFER, cMax=COLS-1+BUFFER;
  for(let key of external.keys()){
    const [r,c]=key.split(',').map(Number);
    if(r<rMin) rMin=r; if(r>rMax) rMax=r;
    if(c<cMin) cMin=c; if(c>cMax) cMax=c;
  }

  const rows=rMax-rMin+1, cols=cMax-cMin+1;
  grid.style.gridTemplateRows=`repeat(${rows}, var(--cell))`;
  grid.style.gridTemplateColumns=`repeat(${cols}, var(--cell))`;

  for(let r=rMin;r<=rMax;r++){
    for(let c=cMin;c<=cMax;c++){
      let cell=document.createElement('div');
      cell.classList.add('cell');
      cell.dataset.r=r;
      cell.dataset.c=c;
      const key=`${r},${c}`;
      let val=null;
      let isHole=false;
      let isBuffer=false;

      if(r>=0 && r<ROWS && c>=0 && c<COLS){
        val=board[r][c].v;
        isHole=board[r][c].hole;
      } else { isBuffer=true; }

      if(external.has(key)) {val=external.get(key).v; isBuffer=false;}

      if(isHole) cell.classList.add('hole');
      else if(val){ cell.classList.add(val); cell.textContent=val; }
      else if(isBuffer) cell.classList.add('buffer');
      else cell.classList.add('empty');

      if(selected && selected.r===r && selected.c===c) cell.classList.add('selected');
      if(validTargets.has(key)) cell.classList.add('valid');

      if(!gameOver) cell.addEventListener('click',onClick);
      grid.appendChild(cell);
    }
  }
}

function onClick(e){
  if(gameOver) return;
  const r=parseInt(e.currentTarget.dataset.r);
  const c=parseInt(e.currentTarget.dataset.c);
  const key=`${r},${c}`;

  if(mode==='place'){
    if(r>=0 && r<ROWS && c>=0 && c<COLS){
      if(board[r][c].v || board[r][c].hole){ status.textContent='Casella occupata o buco'; return;}
      board[r][c].v=current;
      if(checkWin(current)){ render(); gameOver=true; showWinner(current); return;}
      switchPlayer();
      render();
      status.textContent='Piazza '+current;
    }
  } else if(mode==='move'){
    if(!selected){
      if(r>=0 && r<ROWS && c>=0 && c<COLS){
        if(!board[r][c].v || board[r][c].v!==current){ status.textContent='Seleziona tuo pezzo sul bordo'; return;}
        if(r!==0 && r!==ROWS-1 && c!==0 && c!==COLS-1){ status.textContent='Solo pezzi del bordo interno'; return;}
        selected={r,c};
        board[r][c].v=null; board[r][c].hole=true;
        validTargets = computeValidTargets();
        status.textContent='Selezionato. Clicca posizione esterna evidenziata.';
        render();
      }
    } else {
      if(!validTargets.has(key)){ status.textContent='Seleziona posizione valida'; return;}
      external.set(key,{v:current});
      selected=null;
      validTargets.clear();
      if(checkWin(current)){ render(); gameOver=true; showWinner(current); return;}
      switchPlayer();
      render();
      status.textContent='Piazza '+current;
    }
  }
}

function showWinner(player){
  winnerText.textContent='Vince: '+player;
  winnerPopup.style.display='block';
}

function computeValidTargets(){
  const targets = new Set();
  const dirs=[[0,1],[1,0],[0,-1],[-1,0]];
  const occupied = new Set();

  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(board[r][c].v || board[r][c].hole) occupied.add(`${r},${c}`);
  for(let key of external.keys()) occupied.add(key);

  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      if(board[r][c].v || board[r][c].hole){
        for(const [dr,dc] of dirs){
          const nr=r+dr, nc=c+dc, k=`${nr},${nc}`;
          if(nr<0 || nr>=ROWS || nc<0 || nc>=COLS){ 
            if(!occupied.has(k)) targets.add(k);
          }
        }
      }
    }
  }

  for(let key of external.keys()){
    const [r,c]=key.split(',').map(Number);
    for(const [dr,dc] of dirs){
      const nr=r+dr, nc=c+dc, k=`${nr},${nc}`;
      if(!occupied.has(k)) targets.add(k);
    }
  }

  return targets;
}

function switchPlayer(){current=current==='X'?'O':'X';}

function checkWin(player){
  const allCells = new Map();
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) allCells.set(`${r},${c}`,board[r][c].v);
  for(let [k,v] of external.entries()) allCells.set(k,v.v);

  const dirs=[[1,0],[0,1]]; 
  for(let [key,v] of allCells){
    if(v!==player) continue;
    const [r,c]=key.split(',').map(Number);
    for(const [dr,dc] of dirs){
      let count=1;
      for(let k1=1;k1<4;k1++){ let nk=`${r+dr*k1},${c+dc*k1}`; if(allCells.get(nk)!==player) break; count++; }
      for(let k1=1;k1<4;k1++){ let nk=`${r-dr*k1},${c-dc*k1}`; if(allCells.get(nk)!==player) break; count++; }
      if(count>=4) return true;
    }
  }
  return false;
}

document.getElementById('placeBtn').addEventListener('click',()=>{if(gameOver) return; mode='place'; selected=null; validTargets.clear(); status.textContent='Modalità Piazza: piazza '+current; render();});
document.getElementById('moveBtn').addEventListener('click',()=>{if(gameOver) return; mode='move'; selected=null; validTargets.clear(); status.textContent='Modalità Muovi: seleziona bordo interno'; render();});
document.getElementById('resetBtn').addEventListener('click',()=>{location.reload();});

render();
</script>
</body>
</html>